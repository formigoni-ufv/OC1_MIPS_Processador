$date
	Sun Jun 04 23:32:54 2017
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module processor $end
$var wire 1 ! zero $end
$var wire 32 " sllOut [31:0] $end
$var wire 1 # regWrite $end
$var wire 5 $ regDstOut [4:0] $end
$var wire 1 % regDst $end
$var wire 32 & reg2content [31:0] $end
$var wire 32 ' reg1content [31:0] $end
$var wire 32 ( pcOut [31:0] $end
$var wire 32 ) pcIn [31:0] $end
$var wire 32 * memtoRegOut [31:0] $end
$var wire 1 + memWrite $end
$var wire 1 , memRead $end
$var wire 32 - insMemOut [31:0] $end
$var wire 32 . extOut [31:0] $end
$var wire 32 / dataMemOut [31:0] $end
$var wire 32 0 branchAluOut [31:0] $end
$var wire 1 1 branch $end
$var wire 1 2 andGateOut $end
$var wire 32 3 aluSrcOut [31:0] $end
$var wire 1 4 aluSrc $end
$var wire 32 5 aluPCPlus4Out [31:0] $end
$var wire 32 6 aluMainOut [31:0] $end
$var wire 4 7 aluCtrlOut [3:0] $end
$var wire 1 8 MemtoReg $end
$var wire 2 9 ALUOp [1:0] $end
$var reg 1 : clk $end
$scope module aluControl $end
$var wire 2 ; ALUOp [1:0] $end
$var wire 6 < funcCode [5:0] $end
$var reg 4 = aluCtrlOut [3:0] $end
$upscope $end
$scope module aluPCPlus4 $end
$var wire 32 > B [31:0] $end
$var wire 4 ? OP [3:0] $end
$var wire 1 @ zero $end
$var wire 32 A A [31:0] $end
$var reg 32 B OUT [31:0] $end
$upscope $end
$scope module alumux $end
$var wire 32 C i1 [31:0] $end
$var wire 32 D i0 [31:0] $end
$var wire 1 4 control $end
$var reg 32 E out [31:0] $end
$upscope $end
$scope module branchAlu $end
$var wire 32 F A [31:0] $end
$var wire 4 G OP [3:0] $end
$var wire 1 H zero $end
$var wire 32 I B [31:0] $end
$var reg 32 J OUT [31:0] $end
$upscope $end
$scope module branchmux $end
$var wire 32 K i0 [31:0] $end
$var wire 32 L i1 [31:0] $end
$var wire 1 2 control $end
$var reg 32 M out [31:0] $end
$upscope $end
$scope module controlUnit $end
$var wire 6 N op [5:0] $end
$var reg 1 O ALUOp0 $end
$var reg 1 P ALUOp1 $end
$var reg 1 4 ALUSrc $end
$var reg 1 1 branch $end
$var reg 1 , memRead $end
$var reg 1 + memWrite $end
$var reg 1 8 memtoReg $end
$var reg 1 % regDst $end
$var reg 1 # regWrite $end
$upscope $end
$scope module dataMemMux $end
$var wire 1 8 control $end
$var wire 32 Q i1 [31:0] $end
$var wire 32 R i0 [31:0] $end
$var reg 32 S out [31:0] $end
$upscope $end
$scope module datamem $end
$var wire 1 , memRead $end
$var wire 1 + memWrite $end
$var wire 32 T writeData [31:0] $end
$var wire 32 U addr [31:0] $end
$var reg 32 V readData [31:0] $end
$upscope $end
$scope module ext $end
$var wire 16 W i0 [15:0] $end
$var reg 32 X out [31:0] $end
$upscope $end
$scope module gate $end
$var wire 1 1 i0 $end
$var wire 1 ! i1 $end
$var reg 1 2 out $end
$upscope $end
$scope module insmem $end
$var wire 32 Y addr [31:0] $end
$var reg 32 Z instruction [31:0] $end
$var reg 513 [ memory [512:0] $end
$upscope $end
$scope module mainAlu $end
$var wire 32 \ B [31:0] $end
$var wire 4 ] OP [3:0] $end
$var wire 1 ! zero $end
$var wire 32 ^ A [31:0] $end
$var reg 32 _ OUT [31:0] $end
$upscope $end
$scope module pc $end
$var wire 1 : clock $end
$var wire 32 ` in [31:0] $end
$var reg 1 a kept $end
$var reg 32 b out [31:0] $end
$upscope $end
$scope module regfile $end
$var wire 1 : clk $end
$var wire 32 c data [31:0] $end
$var wire 5 d reg1addr [4:0] $end
$var wire 5 e reg2addr [4:0] $end
$var wire 1 # regWrite $end
$var wire 5 f regWaddr [4:0] $end
$var reg 32 g reg1content [31:0] $end
$var reg 32 h reg2content [31:0] $end
$var reg 1 i update $end
$upscope $end
$scope module regfilemux $end
$var wire 1 % control $end
$var wire 5 j i0 [4:0] $end
$var wire 5 k i1 [4:0] $end
$var reg 5 l out [4:0] $end
$upscope $end
$scope module sll $end
$var wire 32 m i0 [31:0] $end
$var reg 32 n out [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx n
bx m
bx l
bx k
bx j
xi
bx h
bx g
bx f
bx e
bx d
bx c
bx b
xa
bx `
bx _
bx ^
bx ]
bx \
bx000010010 [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
xP
xO
bx N
bx M
bx L
bx K
bx J
bx I
xH
b10 G
bx F
bx E
bx D
bx C
bx B
bx A
x@
b10 ?
b10 >
bx =
bx <
bx ;
x:
bx 9
x8
bx 7
bx 6
bx 5
x4
bx 3
x2
x1
bx 0
bx /
bx .
bx -
x,
x+
bx *
bx )
bx (
bx '
bx &
x%
bx $
x#
bx "
x!
$end
#1
b10 )
b10 M
b10 `
b0 3
b0 E
b0 \
b0 $
b0 f
b0 l
02
0i
b0 &
b0 D
b0 T
b0 h
b0 '
b0 ^
b0 g
0O
b10 9
b10 ;
1P
01
0+
0,
1#
08
04
1%
0H
b10 0
b10 J
b10 L
b0 "
b0 I
b0 n
b0 .
b0 C
b0 X
b0 m
b0 <
b0 e
b0 d
b0 W
b0 k
b0 j
b0 N
b0 -
b0 Z
0@
b10 5
b10 B
b10 F
b10 K
b0 (
b0 A
b0 Y
b0 b
0a
#50
bx 3
bx E
bx \
bx &
bx D
bx T
bx h
0i
0:
#100
b100 )
b100 M
b100 `
b100 0
b100 J
b100 L
b100 5
b100 B
b100 F
b100 K
b10 (
b10 A
b10 Y
b10 b
1:
#150
0i
0:
#200
b100 "
b100 I
b100 n
b1 .
b1 C
b1 X
b1 m
b1 <
b1 W
b110 )
b110 M
b110 `
b1 -
b1 Z
b1010 0
b1010 J
b1010 L
b110 5
b110 B
b110 F
b110 K
b100 (
b100 A
b100 Y
b100 b
1:
#250
0i
0:
#300
b0 "
b0 I
b0 n
b0 .
b0 C
b0 X
b0 m
b0 <
b0 W
b1000 )
b1000 M
b1000 `
b0 -
b0 Z
b1000 0
b1000 J
b1000 L
b1000 5
b1000 B
b1000 F
b1000 K
b110 (
b110 A
b110 Y
b110 b
1:
#350
0i
0:
